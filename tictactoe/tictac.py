'''Algorithms for playing the game of tic-tac-toe.

We represent state as a string of exactly nine characters from 'x', 'o', and
space, such that state[x] corresponds to the board position examined from
top-left to bottom-right. Example:

>>> state = (
...     ' x '
...     'o  '
...     '  x')
>>> printboard(state)
   | X |  
-----------
 O |   |  
-----------
   |   | X

'''
import re

__author__ = 'Michael F. Lamb <mike@datagrok.org>'
__date__ = 'Thu, 20 Jan 2011 01:15:05 -0500'


def state_rotations(state):
    '''Given a tictactoe board state, return all the symmetric variants of the
    same state, and the index to invert the permutation for each.
    '''

    # The tic-tac-toe game board is symmetrical; its movement belongs to the
    # dihedral group of order 8.

    for x in range(4):
        yield (state, x)
        state = rotstate(state)

    #return [(state, 0),
    #(''.join(state[x] for x in [2, 5, 8, 1, 4, 7, 0, 3, 6]), 3), #l1
    #(''.join(state[x] for x in [8, 7, 6, 5, 4, 3, 2, 1, 0]), 2), #l2
    #(''.join(state[x] for x in [6, 3, 0, 7, 4, 1, 8, 5, 2]), 1), #l3
    #(''.join(state[x] for x in [6, 7, 8, 3, 4, 5, 0, 1, 2]), 4), #hflip
    #(''.join(state[x] for x in [0, 3, 6, 1, 4, 7, 2, 5, 8]), 7), #hflip, r1
    #(''.join(state[x] for x in [2, 1, 0, 5, 4, 3, 8, 7, 6]), 6), #hflip, r2
    #(''.join(state[x] for x in [8, 5, 2, 7, 4, 1, 6, 3, 0]), 5), #hflip, r3
    #]


def printboard(state):
    print '\n'.join([
        ' %s | %s | %s',
        '-----------',
        ' %s | %s | %s',
        '-----------',
        ' %s | %s | %s',
    ]) % tuple(state.upper())


class TTTHyde(object):
    '''A container for an implementation of an algorithm to play a "perfect"
    game of tic-tac-toe.
    
    This is an implementation of the algorithm as given here:

        http://webster.cs.ucr.edu/AsmTools/MASM/TicTacToe/ttt_1.html

    I believe the algorithm author's name is Ryan Hyde.

    '''

    # This algorithm employs regular expression objects which match states on
    # the tic-tac-toe board. the regular expression objects contain matching
    # groups that return the state before and after the blank space that the
    # computer will move into given a match. Thus, once a matching state is
    # found, the new state is generated by .expand(\1o\2).)

    re_winning = [re.compile(s) for s in [
        '() (oo......)', # check 8
        '() (..o..o..)', # unneeded
        '() (...o...o)', # check 4
        '(o) (o......)', # check 4
        '(.) (..o..o.)', # check 4
    ]]

    re_blocking = [
        re.compile(rex.pattern.replace('o','x')) for rex in re_winning]

    re_fork_blocking = [re.compile(s) for s in [
        '( ) (x o x  )',
        '() (x xo. ..)',
        '() ( xxo. ..)',
        '() ( x o.x..)',
        '(.) (..x.. .)',
        '() (...x... )',
        '(x.x.) (....)',
    ]]

    re_first_open = re.compile('([xo]*) (.*)')

    def move(self, state):
        '''Given a tictactoe board state, compute and return a new state
        that includes the computer's move.

        Assumes that it is the computer's turn, and that the computer is "o."
        '''

        rotations, mo = self.match_patterns(state)

        if not mo:
            print 'no mo'
            mo = self.re_first_open.match(state)

        try:
            newstate = mo.expand(r'\1o\2')
        except:
            print mo.groups()
            raise

        # re-orient the board correctly
        newstate = rotstate(newstate)[-rotations]

        return newstate


    def match_patterns(self, state):
        '''Helper for move()'''
        for re_pats in [self.re_winning, self.re_blocking, self.re_fork_blocking]:
            for re_pat in re_pats:
                for n, rstate in enumerate(rotstate(state)):
                    mo = re_pat.match(rstate)
                    if mo:
                        return n, mo
        return (0, None)


def __debug_1():
    state = '  x      '
    state = '         '
    while True:
        state = move(state)
        printboard(state)
        state = state.replace('o','t')
        state = state.replace('x','o')
        state = state.replace('t','x')
        state = move(state)
        state = state.replace('o','t')
        state = state.replace('x','o')
        state = state.replace('t','x')
        printboard(state)
        if ' ' not in state:
            break


if __name__ == "__main__":
    import doctest
    doctest.testmod()
